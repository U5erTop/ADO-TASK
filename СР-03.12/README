# Практические задания по DataRelation в ADO.NET

## Задание 1: Создание простого отношения DataRelation между двумя таблицами

**Описание:** Создайте приложение для работы с отношением "один-ко-многим" между таблицами:

1. Создайте DataSet с двумя таблицами: "Категории" (CategoryID, CategoryName, Description) и "Товары" (ProductID, ProductName, Price, CategoryID);
2. Заполните обе таблицы тестовыми данными (минимум 3 категории и 8-10 товаров);
3. Создайте объект DataRelation, связывающий Категории и Товары по CategoryID;
4. Добавьте это отношение в DataSet.Relations;
5. Выведите информацию о созданном отношении (имя, родительская таблица, дочерняя таблица, колонки связи);
6. Создайте метод для вывода иерархической структуры (категория → товары);
7. Обработайте исключения при некорректных связях (несоответствие типов данных, несуществующие колонки).

**Требования:** Используйте правильные типы данных для ключей. Убедитесь, что отношение создано с параметром createConstraints=true. Выведите результаты в структурированном формате (дерево или таблица).

---

## Задание 2: Получение дочерних строк с помощью GetChildRows()

**Описание:** Расширьте приложение из Задания 1 для работы с методом GetChildRows():

1. Используя созданное отношение DataRelation;
2. Для каждой категории получите все связанные товары, используя GetChildRows();
3. Создайте метод, который выводит категорию и всех её товаров с форматированием (например, таблица или список);
4. Реализуйте поиск товаров в конкретной категории;
5. Создайте метод для подсчёта количества товаров в каждой категории;
6. Рассчитайте общую стоимость товаров в категории (сумма Price * Quantity для всех товаров);
7. Создайте фильтр для вывода только категорий, содержащих товары дороже определённой цены.

**Требования:** Обработайте случаи, когда у категории нет товаров. Используйте параметр useParentRows в GetChildRows() если необходимо. Выведите результаты в удобном формате (DataGridView, консоль, текстовый отчёт).

---

## Задание 3: Получение родительских строк с помощью GetParentRows()

**Описание:** Работайте с методом GetParentRows() для получения информации о родительских записях:

1. Используя таблицы из Задания 1 (Категории и Товары);
2. Выберите несколько товаров и получите их родительские категории, используя GetParentRows();
3. Создайте метод, который выводит информацию о товаре вместе с его категорией;
4. Реализуйте поиск товара по ID и вывод полной информации (товар + его категория);
5. Создайте отчёт, который показывает: товар → категория → описание категории;
6. Обработайте случаи, когда товар не имеет родительской категории (orphaned records);
7. Добавьте функциональность для выявления нарушений ссылочной целостности.

**Требования:** Используйте GetParentRows() с параметром DataRowVersion если нужно получить историческую информацию. Обработайте исключения при отсутствии связи. Покажите разницу между GetParentRows() для Modified и Deleted строк.

---

## Задание 4: Создание отношения "сам к себе" для иерархических данных

**Описание:** Создайте приложение для работы с самоссылающейся таблицей (иерархия сотрудников):

1. Создайте таблицу "Сотрудники" (EmployeeID, EmployeeName, Department, Salary, ManagerID);
2. ManagerID содержит ссылку на другого сотрудника (руководителя) или NULL для главы компании;
3. Создайте отношение DataRelation "сам к себе": связь EmployeeID с ManagerID;
4. Заполните таблицу иерархическими данными (глава компании → отделы → менеджеры → сотрудники);
5. Создайте метод для вывода иерархии сотрудников (дерево структуры организации);
6. Для каждого сотрудника выведите его руководителя (используя GetParentRows());
7. Для каждого менеджера выведите его подчинённых (используя GetChildRows());
8. Реализуйте подсчёт глубины иерархии (на каком уровне находится каждый сотрудник).

**Требования:** Обработайте циклические ссылки (если менеджер указывает на сам себя). Выведите иерархию в удобном формате (дерево с отступами, TreeView, XML). Добавьте валидацию для предотвращения нарушений целостности.

---

## Задание 5: Получение данных из отношения "сам к себе" с фильтрацией

**Описание:** Расширьте приложение из Задания 4 для работы с фильтрацией и поиском:

1. Используя созданное отношение "сам к себе";
2. Создайте метод для поиска всех сотрудников, подчиняющихся конкретному менеджеру (прямые подчинённые);
3. Создайте метод для получения всей цепочки руководства для конкретного сотрудника (от сотрудника до главы компании);
4. Реализуйте поиск всех сотрудников определённого уровня иерархии (например, все руководители отделов);
5. Создайте отчёт со статистикой по иерархии (количество уровней, распределение сотрудников по уровням, среднее количество подчинённых);
6. Реализуйте поиск "коллег" (сотрудников, имеющих одного руководителя);
7. Добавьте функцию для вывода информации о "вышестоящих" сотрудниках (все руководители над данным сотрудником, начиная с прямого начальника).

**Требования:** Используйте рекурсивные методы для обхода иерархии. Обработайте отсутствие руководителя (NULL). Выведите результаты в структурированном виде.

---

## Задание 6: Реализация отношения многие-ко-многим через промежуточную таблицу

**Описание:** Создайте систему для работы с отношением "многие-ко-многим":

1. Создайте три таблицы:
   - "Студенты" (StudentID, StudentName, Email);
   - "Курсы" (CourseID, CourseName, Instructor);
   - "Регистрация" (RegistrationID, StudentID, CourseID, EnrollmentDate, Grade);
2. Таблица "Регистрация" является промежуточной и содержит связи между студентами и курсами;
3. Создайте два отношения DataRelation:
   - Между "Студенты" и "Регистрация" (один студент → много регистраций);
   - Между "Курсы" и "Регистрация" (один курс → много регистраций);
4. Заполните таблицы тестовыми данными;
5. Создайте метод для получения всех курсов, на которые записан конкретный студент;
6. Создайте метод для получения всех студентов на конкретном курсе;
7. Выведите статистику: количество студентов на каждом курсе, количество курсов для каждого студента.

**Требования:** Используйте оба отношения DataRelation для навигации. Обработайте случаи пустых регистраций. Выведите результаты в виде матрицы или таблицы.

---

## Задание 7: Навигация по отношению многие-ко-многим в обе стороны

**Описание:** Расширьте приложение из Задания 6 для полной навигации по отношениям:

1. Используя созданные отношения многие-ко-многим;
2. Для студента: получите все его курсы и оценки (используя GetChildRows() от таблицы Регистрация, затем GetParentRows() к Курсы);
3. Для курса: получите всех его студентов и их оценки (используя GetChildRows() от таблицы Регистрация, затем GetParentRows() к Студенты);
4. Создайте метод для поиска студентов, которые учатся на одних и тех же курсах;
5. Создайте метод для вывода полной информации о регистрации (студент → регистрация → курс);
6. Рассчитайте среднюю оценку для каждого студента;
7. Рассчитайте среднюю оценку студентов на каждом курсе;
8. Найдите лучших студентов (средняя оценка выше 4.5) и их курсы.

**Требования:** Используйте GetChildRows() и GetParentRows() в комбинации. Обработайте отсутствие оценок (NULL). Выведите результаты в понятном формате.

---

## Задание 8: Использование DataRelation для создания рассчитываемых полей

**Описание:** Создайте приложение, которое использует отношения для вычисления агрегированных данных:

1. Используя таблицы "Категории" и "Товары" из Задания 1;
2. Добавьте новую колонку "TotalProductCount" в таблицу Категории для хранения количества товаров;
3. Добавьте новую колонку "TotalCategoryValue" в таблицу Категории для хранения суммарной стоимости товаров;
4. Создайте выражение (Expression) в колонке, которое автоматически рассчитывает количество товаров в категории, используя отношение DataRelation;
5. Создайте выражение для подсчёта суммарной стоимости (это может быть сложнее, может потребоваться метод для пересчёта);
6. При добавлении новых товаров проверьте, что рассчитываемые поля обновляются;
7. При удалении товара проверьте пересчёт значений.

**Требования:** Используйте синтаксис выражений DataColumn (функции Count, Sum и т.д.). Продемонстрируйте работу рассчитываемых полей. Обработайте ошибки в выражениях.

---

## Задание 9: Использование DeleteRule для определения поведения при удалении родительской записи

**Описание:** Создайте приложение для демонстрации различных DeleteRule:

1. Создайте две таблицы: "Отделы" (DepartmentID, DepartmentName) и "Сотрудники" (EmployeeID, EmployeeName, DepartmentID, Salary);
2. Создайте отношение DataRelation между ними;
3. Создайте несколько вариантов этого отношения с разными DeleteRule:
   - Вариант 1: DeleteRule.Cascade (удаление отдела удаляет всех его сотрудников);
   - Вариант 2: DeleteRule.SetNull (удаление отдела устанавливает DepartmentID в NULL для сотрудников);
   - Вариант 3: DeleteRule.None (запрещает удаление отдела, если есть сотрудники);
4. Для каждого варианта продемонстрируйте попытку удалить отдел, который имеет сотрудников;
5. Выведите результаты для каждого DeleteRule (какие строки были удалены, изменены или какая ошибка произошла);
6. Обработайте исключения при нарушении правил целостности.

**Требования:** Используйте ForeignKeyConstraint для установки правил. Выведите состояние таблиц до и после удаления. Покажите разницу в поведении для каждого DeleteRule.

---

## Задание 10: Использование UpdateRule для определения поведения при изменении первичного ключа

**Описание:** Создайте приложение для демонстрации различных UpdateRule:

1. Используя таблицы "Отделы" и "Сотрудники" из Задания 9;
2. Измените значение DepartmentID в таблице "Отделы" (например, замените ID 1 на ID 101);
3. Создайте три варианта отношения с разными UpdateRule:
   - Вариант 1: UpdateRule.Cascade (изменение ID отдела обновляет ID в таблице Сотрудники);
   - Вариант 2: UpdateRule.SetNull (изменение ID отдела устанавливает NULL для связанных сотрудников);
   - Вариант 3: UpdateRule.None (запрещает изменение ID отдела, если есть сотрудники);
4. Для каждого варианта продемонстрируйте результаты изменения;
5. Выведите состояние таблиц до и после изменения;
6. Обработайте исключения при нарушении правил целостности.

**Требования:** Используйте ForeignKeyConstraint для установки UpdateRule. Покажите разницу в поведении для каждого правила. Обработайте случаи, когда обновление нарушает целостность данных.

---

## Задание 11: Комбинирование DeleteRule и UpdateRule в одном приложении

**Описание:** Создайте систему управления заказами, которая использует оба правила:

1. Создайте три таблицы: "Заказчики" (CustomerID, CustomerName, Email), "Заказы" (OrderID, OrderDate, CustomerID, Total), "ОрдеротовыеКетали" (DetailID, OrderID, ProductID, Quantity, Price);
2. Создайте два отношения:
   - Заказчики → Заказы (DeleteRule=Cascade, UpdateRule=Cascade);
   - Заказы → ОрдеротовыеДетали (DeleteRule=Cascade, UpdateRule=Cascade);
3. Заполните таблицы тестовыми данными;
4. Реализуйте функции:
   - Добавление нового заказчика;
   - Удаление заказчика (должны удалиться все его заказы и детали заказов);
   - Изменение ID заказчика (должны обновиться все связанные заказы);
   - Добавление заказа;
   - Удаление заказа (должны удалиться все детали заказа);
   - Изменение ID заказа (должны обновиться все его детали);
5. Создайте отчёт о результатах операций (сколько записей было удалено/изменено).

**Требования:** Используйте Cascade для обоих правил. Обработайте все исключения. Выведите иерархию данных до и после операций.

---

## Задание 12: Использование RowState для получения информации о удаляемых строках

**Описание:** Создайте приложение для отслеживания удаляемых записей:

1. Используя таблицы из Задания 1 (Категории и Товары);
2. Создайте отношение между ними;
3. Выполните следующие операции:
   - Добавьте 2 новых товара;
   - Модифицируйте 2 товара;
   - Помечьте 3 товара на удаление (используя DataRow.Delete());
   - НЕ сохраняйте изменения в БД (только в памяти);
4. Используя RowState, создайте метод для получения всех строк, помеченных на удаление (Deleted);
5. Для каждого товара, помеченного на удаление, выведите информацию о его родительской категории (используя GetParentRows());
6. Создайте отчёт перед удалением, показывающий:
   - Какие товары будут удалены;
   - К каким категориям они относятся;
   - Сколько товаров останется в каждой категории;
7. Реализуйте функцию "отмены удаления" (RejectChanges) для конкретных строк.

**Требования:** Используйте RowState.Deleted для фильтрации. Используйте GetParentRows() для получения связанной информации. Выведите результаты в удобном формате. Обработайте ошибки при работе с удалёнными строками.

---

## Задание 13: Получение связанной информации для строк со статусом Added

**Описание:** Создайте приложение для анализа новых добавленных записей:

1. Используя таблицы "Студенты" и "Курсы" из Задания 6 (многие-ко-многим);
2. Добавьте несколько новых регистраций студентов на курсы;
3. Используя RowState.Added, получите все новые регистрации;
4. Для каждой новой регистрации получите:
   - Информацию о студенте (используя GetParentRows());
   - Информацию о курсе (используя GetParentRows());
5. Создайте отчёт о новых регистрациях перед сохранением;
6. Добавьте валидацию: проверьте, что студент и курс существуют;
7. Подсчитайте количество новых регистраций для каждого студента и каждого курса.

**Требования:** Используйте RowState.Added для фильтрации. Используйте оба отношения для получения полной информации. Обработайте случаи, когда связанные записи не существуют.

---

## Задание 14: Получение связанной информации для строк со статусом Modified

**Описание:** Создайте приложение для анализа изменённых записей:

1. Используя таблицы из Задания 6 (Студенты, Курсы, Регистрация);
2. Модифицируйте несколько регистраций (измените оценки);
3. Используя RowState.Modified и DataRowVersion, создайте отчёт:
   - Какие регистрации были изменены;
   - Какая была старая оценка (Original);
   - Какая стала новая оценка (Current);
   - Информация о студенте и курсе;
4. Создайте метод для вывода "дельты" изменений (что изменилось и на сколько);
5. Добавьте валидацию перед сохранением (оценка должна быть от 2 до 5);
6. Подсчитайте статистику изменений (сколько оценок повысилось, понизилось, остались без изменений).

**Требования:** Используйте RowState.Modified и DataRowVersion.Current/Original. Используйте GetParentRows() для получения связанной информации. Выведите результаты в таблице или отчёте.

---

## Задание 15: Каскадное удаление с отслеживанием изменений во всех таблицах

**Описание:** Создайте приложение для отслеживания каскадного удаления:

1. Используя многоуровневую иерархию из Задания 11 (Заказчики → Заказы → Детали Заказов);
2. Установите DeleteRule.Cascade для всех отношений;
3. Удалите заказчика (это должно каскадно удалить все его заказы и детали);
4. Создайте метод для анализа всех удалённых строк во всех таблицах:
   - Получите все строки со статусом Deleted из каждой таблицы;
   - Для каждой удалённой строки выведите информацию о её связях;
5. Используя отношения DataRelation, покажите цепочку удаления (заказчик → его заказы → их детали);
6. Создайте отчёт перед AcceptChanges() с полной информацией об удалённых записях;
7. Реализуйте функцию полного отката изменений (RejectChanges).

**Требования:** Используйте RowState.Deleted и GetParentRows(). Отследите все уровни удаления. Выведите полную иерархию удалённых данных.

---

## Задание 16: Проверка ссылочной целостности перед сохранением

**Описание:** Создайте приложение для валидации ссылочной целостности:

1. Создайте таблицы с отношениями (например, Категории ↔ Товары);
2. Попробуйте добавить товар с несуществующей CategoryID (нарушение целостности);
3. Создайте метод CheckReferentialIntegrity(), который:
   - Проверяет все связанные таблицы через DataRelation;
   - Находит orphaned records (записи без родителя);
   - Находит записи с NULL значениями в колонках ограничений;
   - Выводит отчёт о нарушениях;
4. Добавьте возможность автоматического исправления (удаление orphaned records или установка NULL);
5. Создайте отчёт перед сохранением в БД, если есть нарушения целостности.

**Требования:** Используйте ForeignKeyConstraint и отношения DataRelation для проверки. Обработайте все типы нарушений. Выведите подробный отчёт.

---

## Задание 17: Использование DataRelation для фильтрации данных в DataView

**Описание:** Создайте приложение для фильтрации данных через отношения:

1. Используя таблицы "Заказчики" и "Заказы" с отношением между ними;
2. Создайте DataView на основе таблицы Заказы;
3. Используя отношение DataRelation, реализуйте фильтрацию:
   - Показать все заказы конкретного заказчика;
   - Показать заказы, сделанные после определённой даты;
   - Показать заказы на сумму больше указанной;
4. Комбинируйте фильтры (например, заказы Клиента X после даты Y на сумму > Z);
5. Используйте GetChildRows() для получения заказов и фильтрации через DataView;
6. Отобразите результаты в DataGridView;
7. Добавьте сортировку результатов.

**Требования:** Используйте отношения для навигации и GetChildRows(). Используйте DataView для фильтрации и сортировки. Обработайте пустые результаты.

---

## Задание 18: Экспорт иерархических данных с использованием DataRelation

**Описание:** Создайте приложение для экспорта данных в XML и другие форматы:

1. Используя многоуровневую иерархию (например, Отделы → Сотрудники, или Заказчики → Заказы → Детали);
2. Используя отношения DataRelation и методы GetChildRows();
3. Экспортируйте данные в XML, сохраняя иерархическую структуру;
4. Создайте рекурсивный метод для обхода всех уровней иерархии;
5. Экспортируйте также в другие форматы (CSV с иерархией, JSON);
6. Убедитесь, что все связанные данные правильно организованы в экспорте;
7. Создайте функцию импорта из XML обратно в DataSet, восстанавливая отношения.

**Требования:** Используйте DataSet.WriteXml(). Сохраняйте информацию об отношениях. Обработайте ошибки при экспорте/импорте. Выведите результаты в файл.

---

## Задание 19: Комплексное приложение: управление образовательным учреждением

**Описание:** Создайте комплексную систему на базе всех изученных концепций:

1. Создайте DataSet с таблицами:
   - Факультеты (FacultyID, FacultyName);
   - Специальности (SpecialtyID, SpecialtyName, FacultyID);
   - Студенты (StudentID, StudentName, SpecialtyID);
   - Предметы (SubjectID, SubjectName);
   - Оценки (GradeID, StudentID, SubjectID, Grade, Date);

2. Создайте отношения:
   - Факультеты → Специальности (DeleteRule=Cascade, UpdateRule=Cascade);
   - Специальности → Студенты (DeleteRule=SetNull, UpdateRule=Cascade);
   - Студенты → Оценки (один ко многим);
   - Предметы → Оценки (один ко многим);

3. Реализуйте функции:
   - Добавление/удаление факультета (с каскадным удалением);
   - Получение всех студентов факультета (используя GetChildRows());
   - Получение всех оценок студента с информацией о предметах (используя GetChildRows());
   - Расчёт среднего балла студента, специальности, факультета;
   - Отслеживание всех изменений (Added, Modified, Deleted);
   - Валидация ссылочной целостности перед сохранением;

4. Создайте отчёты:
   - По факультетам (количество специальностей, студентов);
   - По студентам (средний балл, оценки по предметам);
   - Об изменениях перед сохранением.

**Требования:** Используйте все изученные концепции. Обработайте все исключения. Выведите результаты в удобном интерфейсе (DataGridView, отчёты).

---

## Задание 20: Оптимизация и производительность при работе с DataRelation на больших объёмах данных

**Описание:** Создайте приложение для анализа производительности работы с отношениями:

1. Создайте большой DataSet с таблицами:
   - Компании (10,000 записей);
   - Отделы (100,000 записей);
   - Сотрудники (1,000,000 записей);

2. Создайте отношения между ними;

3. Реализуйте различные подходы к получению данных и измерьте их производительность:
   - Подход 1: Использование GetChildRows() в цикле;
   - Подход 2: Использование DataView с фильтром;
   - Подход 3: Использование LINQ to DataSet;
   - Подход 4: Использование SQL-запросов для получения данных вместо DataRelation;

4. Для каждого подхода измерьте:
   - Время выполнения;
   - Использование памяти;
   - Количество операций;

5. Создайте отчёт о результатах сравнения;

6. Оптимизируйте самый медленный подход;

7. Добавьте кэширование результатов для повышения производительности;

8. Создайте рекомендации по использованию DataRelation при работе с большими объёмами данных.

**Требования:** Используйте System.Diagnostics для измерения времени. Используйте Stopwatch для точных измерений. Выведите результаты в виде графиков/таблиц. Предоставьте конкретные рекомендации по оптимизации.

---

## Дополнительные рекомендации для всех заданий

- **Обработка исключений:** Используйте try-catch для всех операций с БД и DataSet.
- **Валидация:** Проверяйте типы данных, диапазоны значений, наличие required полей.
- **Логирование:** Добавляйте подробное логирование операций для отладки.
- **Документирование:** Каждый метод должен содержать комментарии о назначении и параметрах.
- **Тестирование:** Создавайте unit-тесты для критических методов.
- **UI:** Используйте DataGridView для отображения иерархических данных, добавляйте кнопки действий.
- **Производительность:** Используйте GetChanges() вместо перебора всех строк, где это возможно.
- **Целостность данных:** Всегда проверяйте ссылочную целостность перед AcceptChanges().